%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Academic Title Page
% LaTeX Template
% Version 2.0 (17/7/17)
%
% This template was downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% WikiBooks (LaTeX - Title Creation) with modifications by:
% Vel (vel@latextemplates.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
% 
% Instructions for using this template:
% This title page is capable of being compiled as is. This is not useful for 
% including it in another document. To do this, you have two options: 
%
% 1) Copy/paste everything between \begin{document} and \end{document} 
% starting at \begin{titlepage} and paste this into another LaTeX file where you 
% want your title page.
% OR
% 2) Remove everything outside the \begin{titlepage} and \end{titlepage}, rename
% this file and move it to the same directory as the LaTeX file you wish to add it to. 
% Then add \input{./<new filename>.tex} to your LaTeX file where you want your
% title page.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[11pt]{scrreprt}

\usepackage[utf8]{inputenc} % Required for inputting international characters
\usepackage[T1]{fontenc} % Output font encoding for international characters

\usepackage{mathpazo} % Palatino font

\usepackage{graphicx}

\usepackage[autostyle=true]{csquotes}
\usepackage[backend=biber,style=authoryear]{biblatex}

\usepackage{parskip}

\usepackage{svg}

\usepackage{algorithm,algorithmicx,algpseudocode}

\usepackage{amsmath}

\addbibresource{report.bib}

\begin{document}

%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\begin{titlepage} % Suppresses displaying the page number on the title page and the subsequent page counts as page 1
	\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % Defines a new command for horizontal lines, change thickness here
	
	\center % Centre everything on the page
	
	%------------------------------------------------
	%	Headings28427,-0.414214) to 234
	%------------------------------------------------
	
	\textsc{\LARGE Carleton University}\\[1.5cm] % Main heading such as the name of your university/college
	
	\textsc{\Large School of Computer Science}\\[0.5cm] % Major heading such as course name
	
	\textsc{\large COMP4905 -- Honours Project}\\[0.5cm] % Minor heading such as course title
	
	%------------------------------------------------
	%	Title
	%------------------------------------------------
	
	\HRule\\[0.4cm]
	
	{\huge\bfseries Formation Flight of UAVs Swarms in an Obstacle--Filled Three--Dimensional Environment}\\[0.4cm] % Title of your document
	
	\HRule\\[1.5cm]
	
	%------------------------------------------------
	%	Author(s)
	%------------------------------------------------
	
	\begin{minipage}{0.4\textwidth}
		\begin{flushleft}
			\large
			\textit{Author}\\
			Yannick \textsc{Abouem} % Your name
		\end{flushleft}
	\end{minipage}
	~
	\begin{minipage}{0.4\textwidth}
		\begin{flushright}
			\large
			\textit{Supervisor}\\
			Prof. Mark \textsc{Lanthier} % Supervisor's name
		\end{flushright}
	\end{minipage}
	
	% If you don't want a supervisor, uncomment the two lines below and comment the code above
	%{\large\textit{Author}}\\
	%John \textsc{Smith} % Your name
	
	%------------------------------------------------
	%	Date
	%------------------------------------------------
	
	\vfill\vfill\vfill % Position the date 3/4 down the remaining page
	
	{\large\today} % Date, change the \today to a set date if you want to be precise
	
	%------------------------------------------------
	%	Logo
	%------------------------------------------------
	
	\vfill\vfill
	\includegraphics[width=0.5\textwidth]{img/B_Logo_V-RGBRedBlackonLight150_130821.png}\\[1cm] % Include a department/university logo - this will require the graphicx package
	 
	%----------------------------------------------------------------------------------------
	
	\vfill % Push the date up 1/4 of the remaining page
	
\end{titlepage}

%----------------------------------------------------------------------------------------

\section*{Abstract}
Abstract goes here!

\section*{Acknowledgements}
This project uses Webots (http://www.cyberbotics.com), an open-source mobile robot simulation software developed by Cyberbotics Ltd.

\tableofcontents

\listoffigures

\chapter{Introduction}

Cooperation among different individuals in a group is often necessary to solve complex problems
that are otherwise harder or impossible to complete for a singular individual. This concept is
true in the field of robotics, where robotic swarms systems, which are systems composed of
numerous small and limited robots \autocite{HO17}, are a crucial area of study. Due to the early
stage of development of this field, there are not many currently existing applications, however
there exists many research projects to test the capabilities of swarm algorithms \autocite{MS20}.
Despite the lack of representation in the industry sector, multi-robot systems have become of
interest recently due to their abilities to resist failures and damages, adaptability to new
environments and low costs \autocite{HO17}.

A specific problem in swarm robotics, is the pattern formation problem, which consists of
"getting a group of robots to form and stay in a specific formation, like a wedge or a chain,
and maintaining that formation" \autocite{LS22}. The robots in the swarm need to coordinate
to maintain a specific shape in order to achieve the desired goal. In this process, different
methods of controlling the swarm can be used, for example the election of a leader or the 
imposition of a certain set of behaviors for each member. There is also a 
distinction between centralized and decentralized pattern formation, where centralized pattern
formation is performed when there exists a centralized unit that coordinates the individual
robots \autocite{HO17}.

In this project we will explore a decentralized and distributed solution to the pattern formation problem.
A distributed approach was chosen because of their robustness to failure, due to their
built-in redundancy since each robot in the swarm receives the same role \autocite{HO17}.
This is advantageous compared to a centralized, non-distributed approach as it
mitigates the possibility of a single point of failure.


\section{Swarms of Unmanned Aerial Vehicles}

A swarm of Unmanned Aerial Vehicles is a swarm of robots where each robot is capable of flight using
a set of rotors. These swarms have multiple uses. They are commonly used in military applications, but
they are also used for civilian applications, such as aerial surveys, disaster management, environment
mapping, search and rescue and for leisure \autocite{TA19}. These are applications that would benefit
from pattern formation, as we can direct the swarm to take an optimal shape for its use case. For 
example, we can choose a shape to best cover an area while performing an aerial survey or environment
mapping, or adopt a chain-like formation to establish communication between two points \autocite{MS20}
which can be deployed at a site of a natural disaster to aid in search and rescue efforts.


\section{Objectives}

The objective of this project is to provide a distributed solution to the pattern formation problem, meaning
build a system of multiple robots capable of positioning themselves in a specific shape and maintain this
shape while navigating an environment dotted by obstacles. This will be achieved using obstacle detection
and avoidance techniques, as well as distributed system principles, such as leader election, and computer
network principles. For this project we chose to use unmanned aerial vehicles to demonstrate the efficacy
of the solution. Similar work being done includes \autocite{HC21}, where a hierarchical approach is applied
to formation control of fixed wing UAVs, by breaking up the swarm into several smaller groups headed by a 
leader.


\chapter{Methodology}

In this chapter we will explore the method used in and considered for this project. Since this project
contains multiple sub-problems we decided to divide this chapter into four sections.

\section{Automated flight}

The first consideration for this project is about the autonomous flight of the UAVs, meaning that there 
should not be any input from the user regarding the flight control. This problem can then be broken down
into two components: the control algorithm that controls the ability of the UAV to fly and the navigation
algorithm that controls the direction of flight.

\subsection{Control Algorithm}

Flight controllers can be subdivided into two categories: linear controllers and non-linear controllers.
Linear controllers use linear methods to control flight, which includes conventional controllers such as
PID, $H_{\infty}$ controller, gain scheduling and Linear Quadratic Regulator. While non-linear controller
are derived from the original dynamic model of the UAVs and arose to overcome shortcomings of linear
controllers. They are generally harder to implement. Some examples are Feedback linearization, backstepping,
sliding mode control, adaptive control, and model predictive control. \autocite{NH20}

For this project we settled on linear controller due to their simplicity to implement, in particular
we considered the PID controller and the LQR controller.

\subsubsection{PID Control}

The Proportional Integral Derivative controller is the most common controller used in industrial settings
due to its usefulness and ease of implementation. \autocite{IL23} The controller is composed by a proportional
element, an integral element and a derivative element, that represent the present, past and future error value\autocite{AM09}. It is usually designed in the structure represented in Fig. \ref{fig:pid}.

\newpage

\begin{figure}
	\begin{center}
		\includesvg{img/pid_img}
	\end{center}
	\caption{Diagram of a conventional PID controller}\label{fig:pid}
\end{figure}

The controller first computes the error at a specific time $t$ ($e(t)$) using Eq. \ref{eq:pid-err}.

\begin{equation}
	e(t) = r(t) - y(t)
	\label{eq:pid-err}
\end{equation}

Where $r(t)$ is the set value and $y(t)$ is the real value of the process \autocite{AM09}. 
Form the computed error the controller then finds a control factor $u(t)$ using a proportional
coefficient ($K_p$), an integral coefficient ($K_I$) and a derivative coefficient ($K_D$) 
using Eq. \ref{eq:pid-u} \autocite{NH20}.

\begin{equation}
	u(t) = K_p e(t) + K_I \int^t_0 e(t) \mathrm{d} t + K_D \frac{\mathrm{d} e(t)}{\mathrm{d}t}
	\label{eq:pid-u}
\end{equation}

In this project we decided to implement a PID controller due to the ease of implementation and the 
higher number of resources available at our disposal.

\subsubsection{LQR Control}

The other option considered, is the Linear-Quadratic Regulator controller (LQR controller), which is the 
optimal linear controller to operate a dynamic system at minimum cost \autocite{NH20}.

\begin{equation}
	J_{LQR} = \int^\infty_0 y_i^T(t) Q y_i (t) + u_i^T (t) R u_i (t) \mathrm{d}t
	\label{eq:lqr-mc}
\end{equation}

Eq. \ref{eq:lqr-mc} computes the minimum quadratic cost ($J_{LQR}$) from the control input $u_i$ and control
output $y_i$, using two weight matrices ($Q$ and $R$) \autocite{NH20}.

\subsection{Navigation Algorithm}

For the navigation algorithm we used a simple algorithm where given a waypoint, we compute the 
derivative component of the PID algorithm. This can be achieved with the following algorithm.

\newpage

% \usepackage{algorithm,algorithmicx,algpseudocode}
\begin{algorithm}
	\floatname{algorithm}{Algorithm\footnotemark}
	\algrenewcommand\algorithmicrequire{\textbf{Input: }}
	\algrenewcommand\algorithmicensure{\textbf{Output: }}
	\caption{Simple algorithm for UAV navigation using PID}\label{alg:nav}
	\begin{algorithmic}[1]
		\Require $u, v, Y$
		\Ensure $Y_d, P_d$
		\State $\alpha \gets ((\mathrm{atan2}(u_y - v_y, u_x - v_x) - Y) + 2 \pi) \mathrm{mod} (2 \pi)$
		\If{$\alpha > \pi$ }
		\State $\alpha \gets \alpha - 2 \pi$
		\EndIf
		\State $Y_d \gets K_{Yd_{max}} \frac{\alpha}{2\pi}$
		\State $P_d \gets \log(|\alpha|)$
		\If{$P_d < K_{Pd_{max}}$}
		\State $P_d \gets K_{Pd_{max}}$
		\ElsIf{$P_d > 0.1$}
		\State $P_d \gets 0.1$
		\EndIf
		\State \textbf{return} $Y_d, P_d$
	\end{algorithmic}
\end{algorithm}

\footnotetext{Adapted from \autocite{CB23} source code}

Where $u$ and $v$ are vectors representing the UAV position and the waypoint position, $Y$ is the current 
yaw angle of the UAV, $Y_d$ and $P_d$ are the yaw angle disturbance and the pitch angle disturbance
respectively, and $K_{Yd_{max}}$ and $K_{Pd_{max}}$ are the maximum allowed disturbance of the yaw and 
pitch respectively.

\section{Obstacle Detection}

\section{Obstacle Avoidance}

Once obstacles are detected, the UAVs should be capable of avoiding them and navigate between them 
until a goal is reached. As explained above, the navigation algorithm used in this project computes
the trajectory to take to reach a specific waypoint, so we can define the path the UAVs have to take
as a list of waypoints. If we restrict the waypoints as being intersections of cells in a grid then
we can abstract this grid as being a graph. Thus, what we wish to do, in this case, is to find a path
from a starting node to a predefined end node, or search the graph for a specific node. 

There exist many algorithms capable of solving this problem, with the most popular being A*.


\subsection{A*}

The most obvious and popular solution is the A* algorithm, which improves on Dijikstra's algorithm
by using heuristics to decide which node should be considered next \autocite{ADA}. However, since we 
are working in an unknown environment where the UAVs gain more knowledge of the obstacles locations as
they progress, the path needs to be re-planned each time a new obstacle is found. This can become
computationally expansive as we need to execute A* multiple times. 

\subsection{Path Planning in Partially-Known Environments with D*}

In conditions where the UAVs do not have complete information about their surroundings it is 
advantageous to use an algorithm that assumes the possibility of potential changes in costs of the nodes. 
One of such algorithms is D*. 

D* is capable of generating optimal paths for sensor equipped robots with a map of the environment that 
can be complete, partial or empty. The algorithm formulates the path planning process as a set of states,
that represent potential robot locations, connected by directional arcs each with an associated cost. The 
algorithm maintains a list of states which cost has changed over time, and each time a cost is changed
the affected states are added onto the list. Instead of re-planning the whole path, D* adjusts the path
from the states where a change in cost happened and subsequent states. Thus, it operates faster in real-life
scenarios than an algorithm that re-plans the whole trajectory each time a new obstacle is found. \autocite{AS94}

Despite its advantage over other algorithms, it is still possible to improve over D*. For example, D* Lite 
claims to be as efficient if not better than D* but with a simpler implementation \autocite{SK05}.

\subsection{Field D*: Improving D* Lite Using Interpolation}

For this project we decided to implement Field D*, due to its promises of minimizing unnecessary turns and
generating less expensive paths than D* and D* Lite. Field D* achieves this by using interpolation in the 
computation of the cost of the path. \autocite{DF06}

Most path planning algorithms that use a grid as underlying graph compute the cost of a node $s$, $g(s)$, using 
Eq. \ref{eq:fds-gs1}.

\begin{equation}
	g(s) = \underset{s' \in nbrs(s)}{\mathrm{min}} [c(s,s') + g(s')]
	\label{eq:fds-gs1}
\end{equation}

Where $nbrs(s)$ is the set of neighbors of node $s$, $c(s,s')$ is the cost of traversing the edge between $s$ and
$s'$, and $g(s')$ is the path cost of $s'$. This assumes that the only possible path is a straight line between
the nodes, resulting in limitations as described by \autocite{DF06}. In order to overcome these limitations,
Field D* finds an approximation of the cost of the path to any cell boundary node $s_b$ using linear interpolation.
To do this, the algorithm assumes that the nodes of the graph are not located at the center of the cells but rather
at the vertices \autocite{DF06}. It then follows Algorithm \ref{alg:fds-cc} to compute the path cost, $v_s$, of a node $s$ given
two of its neighbors $s_a$ and $s_b$.

Field D* is not a faster algorithm than D* Lite, with a planning time 1.7 times slower than its non-interpolation-based counterpart, 
but it offers a more economical path, $96\%$ as costly as D* Lite on average \autocite{DF06}. Its path generation efficiency makes
this algorithm competitive in some settings where minimizing the path cost is the main goal, for example in situation where the 
cost factor is the amount of fuel required to traverse an area.

% \usepackage{algorithm,algorithmicx,algpseudocode}
\begin{algorithm}
	\floatname{algorithm}{Algorithm}
	\algrenewcommand\algorithmicrequire{\textbf{Input: }}
	\algrenewcommand\algorithmicensure{\textbf{Output: }}
	\caption{Field D* path cost computation procedure by \autocite{DF06}}\label{alg:fds-cc}
	\begin{algorithmic}[1]
		\Require $s, s_a, s_b$
		\Ensure $v_s$ 
		\If{$s_a$ is diagonal neighbor of $s$ }
		\State $s_1 \gets s_b$ 
		\State $s_2 \gets s_a$
		\Else
		\State $s_1 \gets s_a$ 
		\State $s_2 \gets s_b$ 
		\EndIf
		\State $c$ is traversal cost of cell with corners $s, s_1, s_2$ 
		\State $b$ is traversal cost of cell with corners $s, s_1$ but not $s_2$.
		\If{$\mathrm{min}(c,b) = \infty$}
		\State $v_s \gets \infty$
		\ElsIf{$g(s_1) \le g(s_2)$}
		\State $v_s \gets \mathrm{min}(c,b) + g(s_1)$
		\Else
		\State $f \gets g(s_1) - g(s_2)$ 
		\If{$f \le b$}
		\If{$c \le f$}
		\State $v_s \gets c \sqrt{2} + g(s_2)$
		\Else
		\State $y \gets \mathrm{min}\left(\frac{f}{\sqrt{c^s - f^s}}, 1\right)$
		\State $v_s \gets c \sqrt{1 + y^2} + f(1 - y) + g(s_2)$
		\EndIf
		\Else
		\If{$c \le b$}
		\State $v_s \gets c \sqrt{2} + g(s_2)$
		\Else 
		\State $x \gets 1 - \mathrm{min}\left(\frac{b}{\sqrt{c^2 - b^2}},1\right)$
		\State $v_s \gets c \sqrt{1 + (1-x)^2} + bx + g(s_2)$
		\EndIf
		\EndIf
		\EndIf
		\State \textbf{return} $v_s$
	\end{algorithmic}
\end{algorithm}




\section{Pattern Formation}


\printbibliography
\end{document}
