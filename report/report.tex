%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Academic Title Page
% LaTeX Template
% Version 2.0 (17/7/17)
%
% This template was downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% WikiBooks (LaTeX - Title Creation) with modifications by:
% Vel (vel@latextemplates.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
% 
% Instructions for using this template:
% This title page is capable of being compiled as is. This is not useful for 
% including it in another document. To do this, you have two options: 
%
% 1) Copy/paste everything between \begin{document} and \end{document} 
% starting at \begin{titlepage} and paste this into another LaTeX file where you 
% want your title page.
% OR
% 2) Remove everything outside the \begin{titlepage} and \end{titlepage}, rename
% this file and move it to the same directory as the LaTeX file you wish to add it to. 
% Then add \input{./<new filename>.tex} to your LaTeX file where you want your
% title page.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[11pt,parskip=full]{scrreprt}

\usepackage[utf8]{inputenc} % Required for inputting international characters
\usepackage[T1]{fontenc} % Output font encoding for international characters

\usepackage{mathpazo} % Palatino font

\usepackage{graphicx}

\usepackage[autostyle=true]{csquotes}
\usepackage[backend=biber,style=authoryear]{biblatex}

\usepackage{svg}

\usepackage{algorithm,algorithmicx,algpseudocode}

\usepackage{amsmath}

\usepackage{subcaption}

\addbibresource{report.bib}

\begin{document}

\renewcommand{\figurename}{FIGURE}

%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\begin{titlepage} % Suppresses displaying the page number on the title page and the subsequent page counts as page 1
	\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % Defines a new command for horizontal lines, change thickness here
	
	\center % Centre everything on the page
	
	%------------------------------------------------
	%	Headings28427,-0.414214) to 234
	%------------------------------------------------
	
	\textsc{\LARGE Carleton University}\\[1.5cm] % Main heading such as the name of your university/college
	
	\textsc{\Large School of Computer Science}\\[0.5cm] % Major heading such as course name
	
	\textsc{\large COMP4905 -- Honours Project}\\[0.5cm] % Minor heading such as course title
	
	%------------------------------------------------
	%	Title
	%------------------------------------------------
	
	\HRule\\[0.4cm]
	
	{\huge\bfseries Formation Flight of UAVs Swarms in an Obstacle--Filled Three--Dimensional Environment}\\[0.4cm] % Title of your document
	
	\HRule\\[1.5cm]
	
	%------------------------------------------------
	%	Author(s)
	%------------------------------------------------
	
	\begin{minipage}{0.4\textwidth}
		\begin{flushleft}
			\large
			\textit{Author}\\
			Yannick \textsc{Abouem} % Your name
		\end{flushleft}
	\end{minipage}
	~
	\begin{minipage}{0.4\textwidth}
		\begin{flushright}
			\large
			\textit{Supervisor}\\
			Prof. Mark \textsc{Lanthier} % Supervisor's name
		\end{flushright}
	\end{minipage}
	
	% If you don't want a supervisor, uncomment the two lines below and comment the code above
	%{\large\textit{Author}}\\
	%John \textsc{Smith} % Your name
	
	%------------------------------------------------
	%	Date
	%------------------------------------------------
	
	\vfill\vfill\vfill % Position the date 3/4 down the remaining page
	
	{\large\today} % Date, change the \today to a set date if you want to be precise
	
	%------------------------------------------------
	%	Logo
	%------------------------------------------------
	
	\vfill\vfill
	\includegraphics[width=0.5\textwidth]{img/B_Logo_V-RGBRedBlackonLight150_130821.png}\\[1cm] % Include a department/university logo - this will require the graphicx package
	 
	%----------------------------------------------------------------------------------------
	
	\vfill % Push the date up 1/4 of the remaining page
	
\end{titlepage}

%----------------------------------------------------------------------------------------

\chapter*{Abstract}
Abstract goes here!

\chapter*{Acknowledgements}
This project uses Webots (http://www.cyberbotics.com), an open-source mobile robot simulation software developed by Cyberbotics Ltd.

\tableofcontents

\listoffigures

\listoftables

\listofalgorithms

\chapter{Introduction}

Cooperation among different individuals in a group is often necessary to solve complex problems
that are otherwise harder or impossible to complete for a singular individual. This concept is
true in the field of robotics where robotic swarms have become an increasingly popular area of study.
Robotic swarms are usually composed of many small and limited individual robots \autocite{HO17}
collaborating to achieve a shared goal.
Due to the early
stage of development of this field, there are not many currently existing applications, however
there exists many research projects to test the capabilities of swarm algorithms \autocite{MS20}.
Despite the lack of representation in the industry sector, multi-robot systems have become of
interest recently due to their abilities to resist failures and damages, adaptability to new
environments and low costs \autocite{HO17}.

A specific problem in swarm robotics is the pattern formation problem, which consists of
"getting a group of robots to form and stay in a specific formation, like a wedge or a chain,
and maintaining that formation" \autocite{LS22}. The robots in the swarm need to coordinate
to maintain a specific shape in order to achieve the desired goal. In this process, different
methods of controlling the swarm can be used, for example the election of a leader or the 
imposition of a certain set of behaviors for each member. There is also a 
distinction between centralized and decentralized pattern formation, where centralized pattern
formation is performed when there exists a centralized unit that coordinates the individual
robots \autocite{HO17}.


\section{Swarms of Unmanned Aerial Vehicles}

A swarm of Unmanned Aerial Vehicles is a swarm of robots where each robot is capable of flight using
a set of rotors. These swarms have multiple uses. They are commonly used in military applications, but
they are also used for civilian applications, such as aerial surveys, disaster management, environment
mapping, search and rescue, and for leisure \autocite{TA19}. These are applications that would benefit
from pattern formation, as we can direct the swarm to take an optimal shape for its use case. For 
example, we can choose a shape to best cover an area while performing an aerial survey or environment
mapping, or adopt a chain-like formation to establish communication between two points \autocite{MS20}
which can be deployed at a site of a natural disaster to aid in search and rescue efforts.


\section{Objectives}

The objective of this project is to provide a distributed solution to the pattern formation problem, meaning
build a system of multiple robots capable of positioning themselves in a specific shape and maintain this
shape while navigating an environment populated by obstacles. This will be achieved using obstacle detection
and avoidance techniques, as well as distributed system principles, such as leader election, and computer
network principles. For this project we chose to use unmanned aerial vehicles to demonstrate the efficacy
of the solution. Similar work being done includes \autocite{HC21}, where a hierarchical approach is applied
to formation control of fixed wing UAVs, by breaking up the swarm into several smaller groups each headed by a 
leader.


\chapter{Methodology}

In this chapter we will explore the method used in and considered for this project. Since this project
contains multiple sub-problems we decided to divide this chapter into four sections.

\section{Automated flight}

The first consideration for this project is about the autonomous flight of the UAVs, meaning that there 
should not be any input from the user regarding the flight control. This problem can then be broken down
into two components: the control algorithm that controls the ability of the UAV to fly and the navigation
algorithm that controls the direction of flight.

\subsection{Control Algorithm}

Flight controllers can be subdivided into two categories: linear controllers and non-linear controllers.
Linear controllers use linear methods to control flight, which includes conventional controllers such as
PID, $H_{\infty}$ controller, gain scheduling and Linear Quadratic Regulator. On the other hand, non-linear controller
are derived from the original dynamic model of the UAVs and arose to overcome shortcomings of linear
controllers. They are generally harder to implement than linear controllers. Some examples are Feedback linearization, backstepping,
sliding mode control, adaptive control, and model predictive control. \autocite{NH20}

For this project we settled on linear controller due to their simplicity to implement, in particular
we considered the PID controller and the LQR controller.

\subsubsection{PID Control}

The Proportional Integral Derivative controller is the most common controller used in industrial settings
due to its usefulness and ease of implementation. \autocite{IL23} The controller is composed by a proportional
element, an integral element and a derivative element, that represent the present, past and future error value\autocite{AM09}. 
It is usually designed in the structure represented in Fig. \ref{fig:pid}.

\begin{figure}
	\begin{center}
		\includesvg{img/pid_img}
	\end{center}
	\caption{Diagram of a conventional PID controller}\label{fig:pid}
\end{figure}

The controller first computes the error at a specific time $t$ ($e(t)$) using Eq. (\ref{eq:pid-err}).

\begin{equation}
	e(t) = r(t) - y(t)
	\label{eq:pid-err}
\end{equation}

Where $r(t)$ is the set value and $y(t)$ is the real value of the process \autocite{AM09}. 
From the computed error the controller then finds a control factor $u(t)$ using a proportional
coefficient ($K_p$), an integral coefficient ($K_I$) and a derivative coefficient ($K_D$) 
using Eq. (\ref{eq:pid-u}) \autocite{NH20}.

\begin{equation}
	u(t) = K_p e(t) + K_I \int^t_0 e(t) \mathrm{d} t + K_D \frac{\mathrm{d} e(t)}{\mathrm{d}t}
	\label{eq:pid-u}
\end{equation}

In this project we decided to implement a PID controller due to the ease of implementation and the 
higher number of resources available at our disposal.

\subsubsection{LQR Control}

The other option considered, is the Linear-Quadratic Regulator controller (LQR controller), which is the 
optimal linear controller to operate a dynamic system at minimum cost \autocite{NH20}.

\begin{equation}
	J_{LQR} = \int^\infty_0 y_i^T(t) Q y_i (t) + u_i^T (t) R u_i (t) \mathrm{d}t
	\label{eq:lqr-mc}
\end{equation}

Eq. (\ref{eq:lqr-mc}) computes the minimum quadratic cost ($J_{LQR}$) from the control input $u_i$ and control
output $y_i$, using two weight matrices ($Q$ and $R$) \autocite{NH20}.

\subsection{Navigation Algorithm}

For the navigation algorithm we used a simple algorithm where given a waypoint, we compute the 
derivative component of the PID algorithm. This can be achieved with the following algorithm.

% \usepackage{algorithm,algorithmicx,algpseudocode}
\begin{algorithm}
	\floatname{algorithm}{Algorithm}
	\algrenewcommand\algorithmicrequire{\textbf{Input: }}
	\algrenewcommand\algorithmicensure{\textbf{Output: }}
	\caption{Simple algorithm for UAV navigation using PID adapted from \autocite{CB23} source code}\label{alg:nav}
	\begin{algorithmic}[1]
		\Require $u, v, Y$
		\Ensure $Y_d, P_d$
		\State $\alpha \gets ((\mathrm{atan2}(u_y - v_y, u_x - v_x) - Y) + 2 \pi) \mathrm{mod} (2 \pi)$
		\If{$\alpha > \pi$ }
		\State $\alpha \gets \alpha - 2 \pi$
		\EndIf
		\State $Y_d \gets K_{Yd_{max}} \frac{\alpha}{2\pi}$
		\State $P_d \gets \log(|\alpha|)$
		\If{$P_d < K_{Pd_{max}}$}
		\State $P_d \gets K_{Pd_{max}}$
		\ElsIf{$P_d > 0.1$}
		\State $P_d \gets 0.1$
		\EndIf
		\State \textbf{return} $Y_d, P_d$
	\end{algorithmic}
\end{algorithm}

Where $u$ and $v$ are vectors representing the UAV position and the waypoint position, $Y$ is the current 
yaw angle of the UAV, $Y_d$ and $P_d$ are the yaw angle disturbance and the pitch angle disturbance
respectively, and $K_{Yd_{max}}$ and $K_{Pd_{max}}$ are the maximum allowed disturbance of the yaw and 
pitch respectively.

Once the values of $Y_d$ and $P_d$ are computed they are then passed into the PID Controller which computes
the amount of power to the engines necessary to move the UAV on the desired trajectory.

\section{Obstacle Detection}

There exist a wide array of sensors used in obstacle detections, some of these include passive
sensors like cameras and infrared sensors, and active sensors like lidar, radar and ladar. 
Passive sensors absorb energy, like light or infrared waves, to create a picture of the 
environment while active sensors emit their own energy then collect the reflection emitted
by the environment. Active sensors are better suited for our application, as they do not
depend on atmospheric conditions or lighting conditions to operate. However, active sensors
are prone to interference from other sources of electromagnetic waves. \autocite{4432828}
For this project we decided to equip the UAVs with radar to detect obstacles. 

Webots offers a simulation of a radar sensor which detects targets in the environment and 
provides their distance from the sensor, the power received back from the target, the speed relative 
to the sensor, and the horizontal angle (the azimuth) between the target and the sensor \autocite{Webots}.
However, simply knowing this information about the obstacle is not sufficient as we need to find
its position in order to avoid it.

\subsection{Target Coordinates Extraction}

To compute the position of a target we simply need its distance from the sensor, $d$, and the azimuth, 
$\alpha$ from the values returned from Webots API. Assuming that the UAV position is located at the origin,
the distance between the UAV and the target can be considered a vector with magnitude $d$ and the 
azimuth is the angle between the distance vector and the direction vector of the UAV. We call these
vectors $v$ and $u$ respectively. Thus, what we are trying to find is $v = \begin{bmatrix} v_x \\ v_y \end{bmatrix}$.

Given that we have two vectors and the angle between them, we can then find their dot product, where
$\parallel v \parallel = d$, using Eq. (\ref{eq:dotp}).
\begin{equation}
	u . v = \parallel u \parallel \parallel v \parallel \cos \alpha = u_x v_x + u_y v_y
	\label{eq:dotp}
\end{equation}

We assume $u$ is a unit vector. Since $u$ is the direction of the UAV then the angle $\beta$ is the angle between the vector $u$
and the x-axis, and can be calculated from the heading of the UAV. Thus, we can compute the components of $u$ using Eq. 
(\ref{eq:u-comp-1}) and Eq. (\ref{eq:u-comp-2}). 

\begin{align}
	u_x &= \cos \beta
	\label{eq:u-comp-1} \\
	u_y &= \sin \beta
	\label{eq:u-comp-2}
\end{align}

Therefore, we can rewrite Eq. (\ref{eq:dotp}) combined with the values of $u_x$ and $u_y$ resulting in Eq. (\ref{eq:comb}). 

\begin{equation}
	\parallel v \parallel \cos \alpha =  v_x \cos \beta +  v_y \sin \beta
	\label{eq:comb}
\end{equation}

Similarly to $u$, we can also find the components of $v$ using the angle between $v$ and the x-axis, $\gamma$ which
is equal to $\beta - \alpha$. Using this angle we can write an equation to find the components of $v$. 

\begin{equation}
	\tan \gamma = \frac{v_y}{v_x}
	\label{eq:v-comp}
\end{equation}

Eq. (\ref{eq:v-comp}) can then be written in terms of $v_y$ resulting in Eq. (\ref{eq:vy}). 

\begin{equation}
	v_y = v_x \tan \gamma
	\label{eq:vy}
\end{equation}

Finally, we can combine Eq. (\ref{eq:comb}) with Eq. (\ref{eq:vy}) to create one equation to find the x component of $v$. 
\begin{equation}
	v_x = \frac{d \cos \alpha}{\cos \beta + \tan \gamma \sin \beta}
	\label{eq:vx}
\end{equation}

Solving Eq. (\ref{eq:vx}) and Eq. (\ref{eq:vy}) will produce the coordinates of the target relative to the UAV. 
From there it is simply necessary to translate the vector $v$ by the UAV position, resulting in the 
absolute position of the obstacle.

\section{Obstacle Avoidance}

Once obstacles are detected, the UAVs should be capable of avoiding them and navigate between them 
until a goal is reached. As explained above, the navigation algorithm used in this project computes
the trajectory to take to reach a specific waypoint, so we can define the path the UAVs have to take
as a list of waypoints. If we restrict the waypoints as being intersections of cells in a grid then
we can abstract this grid as being a graph. Thus, what we wish to do, in this case, is to find a path
from a starting node to a predefined end node, or search the graph for a specific node. 

There exist many algorithms capable of solving this problem, with the most popular being A*.
In the following subsections we will explore different algorithms considered for this project.


\subsection{A*}

The most obvious and popular solution is the A* algorithm, which improves on Dijikstra's algorithm
by using heuristics to decide which node should be considered next \autocite{ADA}. However, since we 
are working in an unknown environment where the UAVs gain more knowledge of the obstacles locations as
they progress, the path needs to be re-planned each time a new obstacle is found. This can become
computationally expensive as we need to execute A* multiple times. 

\subsection{Path Planning in Partially-Known Environments with D*}

In conditions where the UAVs do not have complete information about their surroundings it is 
advantageous to use an algorithm that assumes the possibility of potential changes in costs of the nodes. 
One of such algorithms is D*. 

D* is capable of generating optimal paths for sensor equipped robots with a map of the environment that 
can be complete, partial or empty. The algorithm formulates the path planning process as a set of states,
that represent potential robot locations, connected by directional arcs each with an associated cost. The 
algorithm maintains a list of states which cost has changed over time, and each time a cost is changed
the affected states are added onto the list. Instead of re-planning the whole path, D* adjusts the path
from the states where a change in cost happened and subsequent states. Thus, it operates faster in real-life
scenarios than an algorithm that re-plans the whole trajectory each time a new obstacle is found. \autocite{AS94}

Despite its advantage over other algorithms, it is still possible to improve over D*. For example, D* Lite 
claims to be as efficient if not better than D* but with a simpler implementation \autocite{SK05}.

\subsection{Field D*: Improving D* Lite Using Interpolation}

For this project we decided to implement Field D*, due to its promises of minimizing unnecessary turns and
generating less expensive paths than D* and D* Lite. Field D* achieves this by using interpolation in the 
computation of the cost of the path. \autocite{DF06}

\begin{figure}
	\begin{center}
		\begin{subfigure}{0.5\textwidth}\centering
			\includesvg{img/fds_cell_img.svg}
			\caption{Representation used by standard algorithms}\label{fig:fds-cell-1}
		\end{subfigure}
		\begin{subfigure}{0.4\textwidth}\centering
			\includesvg{img/fds_cell_img2.svg}
			\caption{Representation used by Field D*}\label{fig:fds-cell-2}
		\end{subfigure}
	\end{center}
	\caption{Representation of nodes positioning in standard path planning algorithms and field D*}\label{fig:fds-cell}
\end{figure}


Most path planning algorithms that use a grid as underlying graph compute the cost of a node $s$, $g(s)$, using 
Eq. (\ref{eq:fds-gs1}).

\begin{equation}
	g(s) = \underset{s' \in nbrs(s)}{\mathrm{min}} [c(s,s') + g(s')]
	\label{eq:fds-gs1}
\end{equation}

Where $nbrs(s)$ is the set of neighbors of node $s$, $c(s,s')$ is the cost of traversing the edge between $s$ and
$s'$, and $g(s')$ is the path cost of $s'$. This assumes that the only possible path is a straight line between
the nodes, resulting in limitations as described by \autocite{DF06}. In order to overcome these limitations,
Field D* finds an approximation of the cost of the path to any cell boundary node $s_b$ using linear interpolation.
To do this, the algorithm assumes that the nodes of the graph are not located at the center of the cells as shown in Fig. \ref{fig:fds-cell-1} but rather
at the vertices as shown in Fig. \ref{fig:fds-cell-2} \autocite{DF06}. It then follows Algorithm \ref{alg:fds-cc} to compute the path cost, $v_s$, of a node $s$ given
two of its neighbors $s_a$ and $s_b$.

Field D* is not a faster algorithm than D* Lite, with a planning time 1.7 times slower than its non-interpolation-based counterpart, 
but it offers a more economical path, $96\%$ as costly as D* Lite on average \autocite{DF06}. Its path generation efficiency makes
this algorithm competitive in some settings where minimizing the path cost is the main goal, for example in situation where the 
cost factor is the amount of fuel required to traverse an area.

% \usepackage{algorithm,algorithmicx,algpseudocode}
\begin{algorithm}
	\floatname{algorithm}{Algorithm}
	\algrenewcommand\algorithmicrequire{\textbf{Input: }}
	\algrenewcommand\algorithmicensure{\textbf{Output: }}
	\caption{Field D* path cost computation procedure by \autocite{DF06}}\label{alg:fds-cc}
	\begin{algorithmic}[1]
		\Require $s, s_a, s_b$
		\Ensure $v_s$ 
		\If{$s_a$ is diagonal neighbor of $s$ }
		\State $s_1 \gets s_b$ 
		\State $s_2 \gets s_a$
		\Else
		\State $s_1 \gets s_a$ 
		\State $s_2 \gets s_b$ 
		\EndIf
		\State $c$ is traversal cost of cell with corners $s, s_1, s_2$ 
		\State $b$ is traversal cost of cell with corners $s, s_1$ but not $s_2$.
		\If{$\mathrm{min}(c,b) = \infty$}
		\State $v_s \gets \infty$
		\ElsIf{$g(s_1) \le g(s_2)$}
		\State $v_s \gets \mathrm{min}(c,b) + g(s_1)$
		\Else
		\State $f \gets g(s_1) - g(s_2)$ 
		\If{$f \le b$}
		\If{$c \le f$}
		\State $v_s \gets c \sqrt{2} + g(s_2)$
		\Else
		\State $y \gets \mathrm{min}\left(\frac{f}{\sqrt{c^s - f^s}}, 1\right)$
		\State $v_s \gets c \sqrt{1 + y^2} + f(1 - y) + g(s_2)$
		\EndIf
		\Else
		\If{$c \le b$}
		\State $v_s \gets c \sqrt{2} + g(s_2)$
		\Else 
		\State $x \gets 1 - \mathrm{min}\left(\frac{b}{\sqrt{c^2 - b^2}},1\right)$
		\State $v_s \gets c \sqrt{1 + (1-x)^2} + bx + g(s_2)$
		\EndIf
		\EndIf
		\EndIf
		\State \textbf{return} $v_s$
	\end{algorithmic}
\end{algorithm}

\newpage

\subsection{Map of the Environment}

In order for Field D* to function it requires access to a \emph{"map"} of the environment
where the cost of each cell and states are stored. This map is, essentially, a grid shaped
graph, where each vertex is connected to eight neighbors, four adjacent and four diagonal. 
The node and its four adjacent neighbors form a cell, which has a specific traversal cost which
is grater than zero. The cost to traverse an edge from a vertex to one of its adjacent neighbors
is equal to the lowest traversal cost of the cells around the edge. While to traverse an edge
from a vertex to a diagonal neighbor, the cost is $c \sqrt{2}$, where $c$ is the traversal cost
of the cell the edge lies into, as shown in \autocite{DF06}. The map is used to compute the 
cost required to reach the goal, and it does not represent the movements the UAV can execute. 

% \usepackage{algorithm,algorithmicx,algpseudocode}
\begin{algorithm}
	\floatname{algorithm}{Algorithm}
	\algrenewcommand\algorithmicrequire{\textbf{Input: }}
	\algrenewcommand\algorithmicensure{\textbf{Output: }}
	\caption{Field D* main loop}\label{alg:fds-loop}
	\begin{algorithmic}[1]
		\Require $M$, $s_{start}$, $s_{goal}$, $OPEN$, $C_{changed}$
		\Ensure $W$
		\For{$x \in C_{changed}$}
			\For{$s \in x$}
				\State \Call{UpdateNode}{$s'$}
			\EndFor
		\EndFor
		\While{$\mathrm{min}_{s \in OPEN}(key(s)) < key(s_{start})$ \textbf{or} $rhs(s_{start}) = g(s_{start}))$}
			\State $s \gets OPEN.pop()$
			\State $nbrs(s) \gets M.getNbrs(s)$
			\If{$g(s) > rhs(s)$}
				\State $g(s) \gets rhs(s)$ 
				\For{$\forall s' \in nbrs(s)$}
					\State \Call{UpdateNode}{$s'$}
				\EndFor
			\Else
				\State $g(s) \gets \infty$
				\For{$\forall s' \in nbrs(s) \cup \{s\}$}
					\State \Call{UpdateNode}{$s'$}
				\EndFor

			\EndIf
		\EndWhile
		\State $W \gets $ ExtractPath($M$, $s_{start}$, $s_{goal}$)
		\State \textbf{return} $W$
	\end{algorithmic}
\end{algorithm}

In our project we decided to encode the map as a two--dimensional array, where each element is 
a cell containing four states. Using pointers we made such that each cell can share its states
with neighboring cells, so we can avoid duplicate states. To extract states and cells from the 
map we developed query functions and other utility functions. 

At the beginning of the program, the map is created, and its values are set to a predetermined
default. All traversal costs are set to one and all states are given default values specified 
by Field D*, meaning that for each state $s$ the values $g(s)$, which is the path cost of 
that state, and $rhs(s)$ which is the one-step lookahead path cost of $s$. We, then,
identify the starting state ($s_{start}$) and the goal state ($s_{goal}$), from the 
initial GPS position of the UAV and a predefined set of coordinates respectively. We further
initialize Filed D* by setting the value of $rhs(s_{goal})$ to zero, create a priority queue
named $OPEN$, and we insert $s_{goal}$ into the queue $OPEN$. Finally, we can compute the 
shortest path using Field D*, as shown in Algorithm \ref{alg:fds-loop}, where $M$ is
the map, $C_{changed}$ is the set of cells whose traversal cost changed and $W$ is the 
set of coordinates that are points on the shortest path in order.

% \usepackage{algorithm,algorithmicx,algpseudocode}
\begin{algorithm}
	\floatname{algorithm}{Algorithm}
	\algrenewcommand\algorithmicrequire{\textbf{Input: }}
	\algrenewcommand\algorithmicensure{\textbf{Output: }}
	\caption{UpdateNode function}\label{alg:upnode}
	\begin{algorithmic}[1]
		\Require $M$, $s_{goal}$, $OPEN$
		\Function{UpdateNode}{$s$}
			\If{$s$ was not visited before}
			\State $g(s) \gets \infty$
			\EndIf
			\If{$s \ne s_{goal}$}
			\State $connbrs(s) \gets M.getConnbrs(s)$
			\For{$\forall (s', s'') \in connbrs(s)$}
				\State $c \gets$ \Call{ComputeCost}{$s$, $s'$, $s''$}
				\If{$c < rhs(s)$}
				\State $rhs(s) \gets c$ 
				\EndIf
			\EndFor
			\EndIf
			\If{$s \in OPEN$}
			\State $OPEN.remove(s)$ 
			\EndIf
			\If{$g(s) \ne rhs(s)$}
			\State $OPEN.insert(s, key(s))$ 
			\EndIf
		\EndFunction
	\end{algorithmic}
\end{algorithm}

\section{Pattern Formation}

The central aspect of this project is pattern formation, which we already
discussed in the previous chapter. In this section we will discuss the technical
detail behind our solution to the pattern formation project. 

\subsection{Leader-follower structure}

In this project, we organized the UAVs in a structure composed of one leader and
multiple followers. The goal of the leader is to plan a path to reach the goal
and communicate each way points to the followers, while the followers simply
fly towards the waypoints assigned by the leader. Each waypoint is computed in 
order to preserve a specific shape dictated by the initial position of the UAVs.

\begin{figure}[h]
	\begin{center}
		\includesvg{img/pf_1.svg}
	\end{center}
	\caption{Graphic of desired pattern transposition from one waypoint to another}\label{fig:pf-1}
\end{figure}

To achieve this each waypoint for each follower is computed not only from the distance 
from the leader but also depending on the expected heading the leader will have. The 
result is expected to look similar to Fig. \ref{fig:pf-1} where the structure of
the formation is not changed when a turn occurs. 

Let $\theta$ be the angle between
the leader UAV direction and the x-axis, we can use this angle as rotation angle for 
the formation. We cannot find the precise heading of the leader UAV due to possible
variance in the real path the UAVs will take, but we can approximate this value given
two waypoints. Let $v$ and $w$ be the current and next waypoints for the leader UAV. 
If we compute the difference of these two waypoints we can find what direction the 
UAV is facing when reaching this waypoint. We show these approximations in Tab. \ref{tab:approx},
where $+$ is a positive difference or $w_x > v_x$, $-$ is a negative difference or $w_x < v_x$
and $0$ is no difference or $w_x = v_x$\footnote{Note: in this example we use the x components of $v$ and $w$, 
but the principle is the same for the y components.}.

\begin{table}
	\caption{Approximations of $\theta$ based on difference of $w - v$}\label{tab:approx}
	\begin{center}
		\begin{tabular}[c]{r|r|c}
			\hline
			\multicolumn{1}{c|}{\textbf{$\Delta x$}} & 
			\multicolumn{1}{c|}{\textbf{$\Delta y$}} &
			\multicolumn{1}{c}{Approx. \textbf{$\theta$}} \\
			\hline
			\hline
			$+$ & $0$ & $0$ \\
			\hline
			$0$ & $+$ & $\frac{1}{2}\pi$ \\
			\hline
			$-$ & $0$ & $\pi$ \\
			\hline
			$0$ & $-$ & $\frac{3}{2}\pi$ \\
			\hline
			$+$ & $+$ & $\frac{1}{4}\pi$ \\
			\hline
			$-$ & $+$ & $\frac{3}{4}\pi$ \\
			\hline
			$-$ & $-$ & $\frac{5}{4}\pi$ \\
			\hline
			$+$ & $-$ & $-\frac{1}{4}\pi$ \\
			\hline
		\end{tabular}
	\end{center}
\end{table}

Once we found the value of $\theta$ we transform the orientation of the formation using a rotation matrix
as shown in Eq. (\ref{eq:rot-mat}).

\begin{equation}
	R = \begin{bmatrix} \cos \theta & -\sin \theta \\ \sin \theta & \cos \theta \end{bmatrix}
	\label{eq:rot-mat}
\end{equation}

Once the formation is rotated it is then translated with respect of the leader waypoint.


\chapter{Program Structure and Inter-UAV communication}

In this chapter we will explore in more detail the program we designed to illustrate our 
solution to the pattern formation problem.

\section{Program Structure}

The program is composed by three phases: an initialization, where all variables and parameters
are initialized, a main loop, where all movements and inter-UAV communication happens, and a 
final clean-up phase. Each UAV's phase is independent of other UAVs and dictated by a state 
variable that can assume one of the values presented in Table \ref{tab:states}. The state 
also serves to determine whether a UAV has been elected leader or not during the execution
of the program. 

\begin{table}
	\caption{Possible values of the state}\label{tab:states}
	\begin{center}
		\begin{tabular}[t]{l|l}
			\hline
			\multicolumn{1}{c|}{\textbf{State value}} & 
			\multicolumn{1}{c}{\textbf{Description}} \\
			\hline 
			\texttt{INIT} & The UAV is in the initialization phase \\
			\hline
			\texttt{RUN} & The UAV is in the main loop phase and has been elected leader \\
			\hline
			\texttt{END} & The goal was reached, and the UAV is in the clean-up phase \\
			\hline
			\texttt{F\_RUN} & The UAV is in the main loop and has not been elected leader \\
			\hline
			\texttt{F\_WAIT} & The UAV is waiting on instructions from the leader, and it is not the leader \\
			\hline
		\end{tabular}
	\end{center}
\end{table}

A full overview of the program structure is available in Fig. \ref{fig:flowchart}.

\begin{figure}
	\begin{center}
		\includesvg{img/flowchart.svg}
	\end{center}
	\caption{The flowchart diagram of the program}\label{fig:flowchart}
\end{figure}

\section{Inter-UAV communication}

In order for the UAVs to cooperate together we equipped each UAV with a transmitter and a 
receiver to send messages to each other. The content of these messages varies depending
on the phase of the program but are generally used to send either the UAV identifier, used
for leader election and for message routing, their initial position, used by the leader
to determine the shape of the formation, and the waypoint the followers need to fly to next. 
Each message is a packet composed of two parts: a header and message. The header contains
metadata necessary to route the message to the correct UAV and the type of message, while 
the message part contains the content of the message which is usually a set of coordinates. 
A diagram of the packet is shown in Fig. \ref{fig:packet}.

\begin{figure}[h]
	\begin{center}
		\includesvg{img/packet.svg}
	\end{center}
	\caption{Diagram of a message. The diagram is 16 bits in width.}\label{fig:packet}
\end{figure}

The header is 4 bytes in size, each field in the header occupy a space of 1 byte, including an 
unused byte. The data part of the message has a maximum size of 16 bytes, however it is only 
used in messages carrying information about the position of the UAV and waypoints. There are 
additional four bytes of padding between the header and the data.

To keep the network simple and decrease the number of failures, all UAVs are connected to each 
other in a complete network as shown in Fig. \ref{fig:net}.

\begin{figure}
	\begin{center}
		\includesvg{img/net.svg}
	\end{center}
	\caption{Network topology diagram}\label{fig:net}
\end{figure}

\subsection{Leader Election}

To implement the pattern formation we need one of the UAVs to become a leader and plan the path. 
To achieve this we decided to implement the FloodMax algorithm for leader election. This is a 
simple algorithm that allows leader election in any network as long as the diameter of the network, $D$,
is known, achieving this in a number of rounds equal to the diameter of the network \autocite{EK23}. 
This is particularly effective in our case, as the diameter of a complete network is 1. See Algorithm
\ref{alg:floodmax} for the steps of FloodMax.

% \usepackage{algorithm,algorithmicx,algpseudocode}
\begin{algorithm}
	\floatname{algorithm}{Algorithm}
	\algrenewcommand\algorithmicrequire{\textbf{Input: }}
	\algrenewcommand\algorithmicensure{\textbf{Output: }}
	\caption{FloodMax Algorithm}\label{alg:floodmax}
	\begin{algorithmic}[1]
		\Require $D$
		\State Each node maintains a record of the highest ID it has seen so far 
		\State At each round the node propagates this maximum to all neighboring nodes
		\State After $D$ rounds if the maximum recorded is equal to the node ID the node elects itself as leader
	\end{algorithmic}
\end{algorithm}


\chapter{Results}

In this section we will showcase the result obtained by applying the concept discussed above as well as some test
scenarios we designed to demonstrate the effectiveness of the solution presented. 

\section{Test scenario}

For this project we constructed three scenarios consisting of different environments and UAVs formations. Each 
scenario is constructed around one of the following use cases for UAVs swarms: disaster management, environment
mapping, search and rescue and industry.

\textbf{Factory scenario}: Four UAVs are placed in a square formation, and they are tasked to carry a box through a 
busy environment like a factory with many obstacles and little room to move in. 

\textbf{Bird flock scenario}: Five UAVs are placed in a V shape similar to a flock of birds and navigate through an
obstacle filled environment.

\textbf{Line scenario}: Five UAVs are placed in a horizontal line, simulating a communication line between two points, and 
navigate in an environment.

\section{Observations from scenarios}

In this section we will discuss observations obtained from the test scenarios above. 
Overall the solution developed performed as expected in each scenario. The main objectives
of the project were met without any faults. Among the three scenarios, the factory
scenario is perhaps the most significant in terms of real world usage. In this scenario
the UAVs were successfully able to navigate through the environment without touching
any obstacles while maintaining the formation as closely as possible. Similarly, 
the other scenarios exhibit similar results. 

Another notable observation is an issue that occurs when the UAVs change direction. 
This issue causes the formation to "stretch" and each follower UAV disperse in a 
different direction which is not desired behavior. We believe that this issue is
caused by the followers reaching the waypoint provided by the leader before the 
leader reaches its own. Since the follower has no new waypoint provided it will then 
wander off until a new waypoint is communicated by the leader. This is less than
ideal and more work is needed to resolve this issue.

\chapter{Conclusion}

In this report we showcased our solution to the pattern formation problem in robotics
for a swarm of unmanned aerial vehicles. We covered different algorithms used to 
control the inputs to the motors of the UAVs and different path planning algorithms,
and explained what the advantages and characteristics of PID control and Field D*. 
We presented our approach to the pattern formation problem and provided a solution 
alongside test scenarios to observe its capabilities.

\printbibliography
\end{document}
